<!DOCTYPE html>
<html lang="en">
<head>
  <script>
  // --- üîí GATEKEEPER SCRIPT ---
  (function checkAccess() {
    const token = localStorage.getItem("token");
    // Uncomment next line to enforce login
    //if (!token) { alert("‚ö†Ô∏è Login required."); window.location.href = "index.html"; return; }
  })();
  
  function logout() { localStorage.clear(); window.location.href = "index.html"; }
  </script>

  <script src="https://cdn.jsdelivr.net/npm/ethers@6.7.0/dist/ethers.umd.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/qrcodejs/1.0.0/qrcode.min.js"></script>

  <script src="config.js"></script>

  <meta charset="UTF-8">
  <title>Issuer Dashboard</title>
  <style>
    /* SHARED CLASSIC THEME */
    body { font-family: "Times New Roman", Times, serif; background-color: #f4f1ea; color: #333; margin: 0; padding: 0; display: flex; flex-direction: column; align-items: center; min-height: 100vh; }
    h2 { text-transform: uppercase; letter-spacing: 2px; border-bottom: 3px double #333; padding-bottom: 15px; margin-top: 50px; margin-bottom: 40px; }
    
    /* Box Styles */
    .box { background: #fff; padding: 30px; width: 500px; border: 1px solid #c0c0c0; box-shadow: 5px 10px 15px rgba(0,0,0,0.1); text-align: center; margin-bottom: 30px;}
    
    /* Inputs & Buttons */
    button { background-color: #2c3e50; color: white; border: 1px solid #1a252f; padding: 10px 25px; cursor: pointer; margin-top: 10px; }
    button:hover { background-color: #1a252f; }
    input[type="file"] { margin-bottom: 15px; padding: 10px; background: #fafafa; border: 1px solid #ccc; width: 90%; }
    
    /* QR Section */
    #qrSection { display: none; margin-top: 20px; border-top: 1px dashed #999; padding-top: 20px; }
    #qrcode { margin-top: 15px; display: flex; justify-content: center; }

    /* --- HISTORY TABLE STYLES --- */
    .wide-box { width: 700px; }
    table { width: 100%; border-collapse: collapse; margin-top: 15px; font-size: 0.9rem; }
    th, td { border: 1px solid #ddd; padding: 8px; text-align: left; }
    th { background-color: #2c3e50; color: white; }
    tr:nth-child(even) { background-color: #f9f9f9; }
    a { color: #2980b9; text-decoration: none; }
    a:hover { text-decoration: underline; }
  </style>
  
</head>
<body>

  <h2>üèõÔ∏è Authority Dashboard</h2>
  
  <div class="box">
    <h3>Document Submission</h3>
    
    <input type="file" id="uploadFile" onchange="showDecisionGate()" />
    
    <div id="decisionGate" style="display:none; text-align: left; background: #fff8e1; padding: 15px; border-left: 5px solid #ffa000; margin: 20px 0;">
      
      <h4 style="margin-top:0; color: #d35400;">ü§î Smart Feature: Embed QR?</h4>
      <p style="font-size: 0.9rem; color: #555;">
        We can automatically place a <strong>Verification QR Code</strong> directly onto this document.
      </p>

      <div style="background: #fff; border: 1px solid #ddd; padding: 10px; font-size: 0.85rem; color: #444; margin-bottom: 15px;">
        <strong>‚ö†Ô∏è CRITICAL DISCLAIMER:</strong><br>
        If you choose <strong>"Yes"</strong>, the system will modify your file. 
        The <strong>Modified File</strong> (with QR) will be the one recorded on the blockchain. 
        <br><br>
        <em>The original file on your computer will NOT verify against the blockchain record. You must use the new QR-stamped version.</em>
      </div>

      <div style="display: flex; gap: 10px; justify-content: center;">
        <button onclick="handleDecision('no')" style="background: #95a5a6; border: none;">
          No, Keep Original
        </button>
        <button onclick="handleDecision('yes')" style="background: #27ae60; border: none;">
          Yes, Embed QR ‚ú®
        </button>
      </div>
    </div>

    <div id="previewSection" style="display:none; text-align: center; border: 1px solid #ccc; padding: 15px; margin-top: 20px;">
      
      <h4>‚ú® Interactive Preview</h4>
      <p id="aiMessage" style="font-size: 0.9rem; color: #555;">AI has suggested a spot.</p>
      <p style="font-size: 0.8rem; color: #2980b9; font-weight: bold;">
        üñ±Ô∏è Drag the QR code to move it | üìè Use slider to resize
      </p>

      <div style="margin: 10px 0;">
          <label for="qrSizeSlider">QR Size:</label>
          <input type="range" id="qrSizeSlider" min="50" max="300" value="150" oninput="updateQRSize(this.value)">
      </div>

      <canvas id="docCanvas" style="max-width: 100%; border: 1px solid #ddd; box-shadow: 2px 2px 10px rgba(0,0,0,0.1); cursor: move;"></canvas>
      
      <br><br>
      <p style="font-size: 0.8rem; color: red;">* This modified image will be hashed and registered.</p>
      
      <button onclick="confirmSmartQR()" style="background: #27ae60; color: white; padding: 10px 20px; border: none; cursor: pointer;">
        ‚úÖ Confirm & Upload
      </button>
      <button onclick="cancelSmartQR()" style="background: #c0392b; color: white; padding: 10px 20px; border: none; cursor: pointer;">
        ‚ùå Cancel
      </button>
    </div>

    <div id="uploadActions" style="display:none;">
        <br>
        <button onclick="uploadDocument()">üöÄ Upload & Register</button>
    </div>

    <p id="uploadResult" style="background:#f9f9f9; padding:10px; margin-top:10px;">Waiting for input...</p>

    <div id="qrSection">
      <h4>üéâ Verification Link Ready</h4>
      <p>Do you want to generate a standalone QR code for this document?</p>
      <button onclick="generateQR()">Yes, Generate QR</button>
      <div id="qrcode"></div>
    </div>
  </div>

  <div class="box wide-box">
    <h3>üìú Your Upload History</h3>
    <button onclick="loadHistory()">üîÑ Refresh History</button>
    <table id="historyTable">
      <thead>
        <tr>
          <th>Hash (Click to Verify)</th>
          <th>IPFS Link</th>
          <th>Block #</th>
        </tr>
      </thead>
      <tbody>
        <tr><td colspan="3" style="text-align:center;">Click Refresh to load data...</td></tr>
      </tbody>
    </table>
  </div>

<script>
  // --- 1. CONFIGURATION ---
  const PINATA_JWT = CONFIG.PINATA_JWT;
  const API_URL = CONFIG.API_URL;
  const contractAddress = CONFIG.CONTRACT_ADDRESS; 
  
  const contractABI = [
    { "anonymous": false, "inputs": [ { "indexed": true, "internalType": "bytes32", "name": "fileHash", "type": "bytes32" }, { "indexed": false, "internalType": "string", "name": "ipfsCid", "type": "string" }, { "indexed": false, "internalType": "address", "name": "owner", "type": "address" } ], "name": "DocumentRegistered", "type": "event" },
    { "inputs": [ { "internalType": "bytes32", "name": "_fileHash", "type": "bytes32" }, { "internalType": "string", "name": "_ipfsCid", "type": "string" } ], "name": "registerDocument", "outputs": [], "stateMutability": "nonpayable", "type": "function" }
  ];

  // --- SMART QR VARIABLES ---
  let finalUploadBlob = null;
  let useSmartQR = false;
  let qrState = { x: 0, y: 0, size: 150, img: null, qrImg: null }; 
  let isDragging = false;
  let dragOffset = { x: 0, y: 0 };

  // --- 2. UI LOGIC (DECISION GATE) ---
  function showDecisionGate() {
      const fileInput = document.getElementById("uploadFile");
      const decisionGate = document.getElementById("decisionGate");
      const uploadActions = document.getElementById("uploadActions");

      // Reset
      uploadActions.style.display = "none";
      document.getElementById("qrSection").style.display = "none";
      document.getElementById("previewSection").style.display = "none";
      document.getElementById("uploadResult").innerText = "Waiting for decision...";
      finalUploadBlob = null; // Clear previous blobs

      if (fileInput.files.length > 0) {
          decisionGate.style.display = "block";
      } else {
          decisionGate.style.display = "none";
      }
  }

  function handleDecision(choice) {
      document.getElementById("decisionGate").style.display = "none";
      
      if (choice === 'yes') {
          processSmartQR(); // Trigger Interactive Studio
      } else {
          // Standard Mode
          document.getElementById("uploadActions").style.display = "block";
      }
  }

  // --- 3. INTERACTIVE QR STUDIO LOGIC ---
  function processSmartQR() {
      const fileInput = document.getElementById("uploadFile");
      const file = fileInput.files[0];
      
      if (!file || !file.type.startsWith("image/")) {
          alert("‚ö†Ô∏è Please upload a JPG or PNG image to use the Smart QR feature. For PDFs, please use 'No'.");
          document.getElementById("decisionGate").style.display = "block";
          return;
      }

      document.getElementById("previewSection").style.display = "block";
      document.getElementById("aiMessage").innerText = "ü§ñ Analyzing document...";

      const reader = new FileReader();
      reader.onload = function(event) {
          const img = new Image();
          img.onload = function() {
              qrState.img = img; // Save original image
              initInteractiveCanvas(img);
          };
          img.src = event.target.result;
      };
      reader.readAsDataURL(file);
  }

  function initInteractiveCanvas(img) {
      const canvas = document.getElementById("docCanvas");
      const ctx = canvas.getContext("2d");

      // Set Canvas Size
      canvas.width = img.width;
      canvas.height = img.height;

      // Generate Temp QR (Hidden)
      const tempQRDiv = document.getElementById("qrcode");
      tempQRDiv.innerHTML = "";
      
      // Construct Future Link
      const futureLink = window.location.href.replace('issuer.html', 'scan.html') + "?check=secure";
      new QRCode(tempQRDiv, { text: futureLink, width: 256, height: 256 });

      // Wait for QR to render, then start interaction
      setTimeout(() => {
          const qrSrc = tempQRDiv.querySelector("img").src;
          const qrImg = new Image();
          qrImg.onload = function() {
              qrState.qrImg = qrImg;
              
              // Initial Position (Bottom Right Default)
              qrState.size = 150; 
              qrState.x = canvas.width - qrState.size - 50;
              qrState.y = canvas.height - qrState.size - 50;
              
              document.getElementById("aiMessage").innerText = "‚úÖ Ready! Drag to move | Use slider to resize.";
              
              // Start Loop
              drawCanvas();
              addCanvasListeners(canvas);
          };
          qrImg.src = qrSrc;
      }, 300);
  }

  function drawCanvas() {
      const canvas = document.getElementById("docCanvas");
      const ctx = canvas.getContext("2d");

      // 1. Clear & Draw Doc
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      ctx.drawImage(qrState.img, 0, 0);

      // 2. Draw White Background for QR
      ctx.fillStyle = "white";
      ctx.fillRect(qrState.x - 5, qrState.y - 5, qrState.size + 10, qrState.size + 10);

      // 3. Draw QR Code
      ctx.drawImage(qrState.qrImg, qrState.x, qrState.y, qrState.size, qrState.size);
  }

  function updateQRSize(val) {
      qrState.size = parseInt(val);
      drawCanvas();
  }

  function addCanvasListeners(canvas) {
      canvas.onmousedown = function(e) {
          const rect = canvas.getBoundingClientRect();
          const scaleX = canvas.width / rect.width;
          const scaleY = canvas.height / rect.height;
          const mouseX = (e.clientX - rect.left) * scaleX;
          const mouseY = (e.clientY - rect.top) * scaleY;

          if (mouseX >= qrState.x && mouseX <= qrState.x + qrState.size &&
              mouseY >= qrState.y && mouseY <= qrState.y + qrState.size) {
              isDragging = true;
              dragOffset.x = mouseX - qrState.x;
              dragOffset.y = mouseY - qrState.y;
          }
      };

      canvas.onmousemove = function(e) {
          if (isDragging) {
              const rect = canvas.getBoundingClientRect();
              const scaleX = canvas.width / rect.width;
              const scaleY = canvas.height / rect.height;
              const mouseX = (e.clientX - rect.left) * scaleX;
              const mouseY = (e.clientY - rect.top) * scaleY;

              qrState.x = mouseX - dragOffset.x;
              qrState.y = mouseY - dragOffset.y;
              drawCanvas();
          }
      };

      canvas.onmouseup = function() { isDragging = false; };
      canvas.onmouseleave = function() { isDragging = false; };
  }

  function confirmSmartQR() {
      const canvas = document.getElementById("docCanvas");
      // Convert Canvas to Blob
      canvas.toBlob(function(blob) {
          finalUploadBlob = blob;
          document.getElementById("previewSection").style.display = "none";
          document.getElementById("uploadActions").style.display = "block";
          document.getElementById("uploadResult").innerText = "‚úÖ Modified file ready. Click Upload to finish.";
      }, 'image/jpeg', 0.95);
  }

  function cancelSmartQR() {
      document.getElementById("previewSection").style.display = "none";
      document.getElementById("decisionGate").style.display = "block";
      finalUploadBlob = null;
  }

  // --- 4. INTERNAL BLOCKCHAIN FUNCTION ---
  async function registerDocumentOnBlockchain(hash, cid) {
    console.log("Starting blockchain registration...");
    if (!window.ethereum) throw new Error("MetaMask is not installed!");

    await window.ethereum.request({ method: "eth_requestAccounts" });
    const provider = new ethers.BrowserProvider(window.ethereum);
    const signer = await provider.getSigner();
    const contract = new ethers.Contract(contractAddress, contractABI, signer);

    if (!hash.startsWith("0x")) hash = "0x" + hash;

    const tx = await contract.registerDocument(hash, cid);
    console.log("Tx Sent:", tx.hash);
    await tx.wait();
    console.log("Tx Confirmed");
  }

  // --- 5. UNPIN HELPER ---
  async function unpinFromPinata(cid) {
      console.log(`üóëÔ∏è Rolling back: ${cid}...`);
      try {
          await fetch(`${API_URL}/unpin`, {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({ cid: cid }) 
          });
      } catch (e) { console.error("Rollback failed:", e); }
  }

  // --- 6. UPLOAD LOGIC ---
  async function uploadDocument() {
    const fileInput = document.getElementById("uploadFile");
    const resultText = document.getElementById("uploadResult");
    
    // IMPORTANT: Check if we have a Smart Blob, otherwise use Input File
    const fileToUpload = finalUploadBlob ? finalUploadBlob : fileInput.files[0];
    let uploadedCid = null; 

    if (!fileToUpload) { alert("Please select a file"); return; }
    
    resultText.innerText = "‚è≥ Step 1: Hashing File (Server)...";
    const formData = new FormData();
    formData.append("document", fileToUpload); // Use the correct file source
    const token = localStorage.getItem("token");

    try {
      // A. Get Hash
      const res = await fetch(`${API_URL}/upload`, {
        method: "POST",
        headers: { "Authorization": `Bearer ${token}` },
        body: formData
      });

      if (res.status === 401) { alert("Session expired."); logout(); return; }
      const data = await res.json();
      const docHash = data.hash;

      // B. Upload to IPFS
      resultText.innerText = "‚è≥ Step 2: Uploading to IPFS...";
      const pinataData = new FormData();
      // If blob, we should give it a name, otherwise Pinata might complain
      if (finalUploadBlob) {
        pinataData.append('file', fileToUpload, "smart-qr-doc.jpg");
      } else {
        pinataData.append('file', fileToUpload);
      }
      
      const pinRes = await fetch("https://api.pinata.cloud/pinning/pinFileToIPFS", {
          method: "POST",
          headers: { Authorization: `Bearer ${PINATA_JWT}` },
          body: pinataData
      });
      const pinJson = await pinRes.json();
      uploadedCid = pinJson.IpfsHash; 
      console.log("IPFS CID:", uploadedCid);

      // C. Register on Blockchain
      resultText.innerText = `‚è≥ Step 3: Waiting for MetaMask...`;
      await registerDocumentOnBlockchain(docHash, uploadedCid);
      
      resultText.innerText = `‚úÖ Success! \nHash: ${docHash} \nCID: ${uploadedCid}`;
      window.currentDocHash = docHash; 
      
      // If we made a Smart QR, we don't need the standalone generator
      if (!useSmartQR) {
        document.getElementById("qrSection").style.display = "block";
      } else {
        document.getElementById("qrSection").style.display = "none";
      }

    } catch (err) {
      console.error(err);
      const errorMessage = err.reason || err.message || JSON.stringify(err);

      if (errorMessage.includes("already registered")) {
          resultText.innerText = "‚ö†Ô∏è Document is already registered on the Blockchain!";
          resultText.style.color = "orange";
      } else if (uploadedCid) {
          resultText.innerText = "‚ùå Transaction Failed. Cleaning up IPFS...";
          await unpinFromPinata(uploadedCid); 
      } else {
          resultText.innerText = "‚ùå Error: " + errorMessage;
      }
    }
  }

  // --- 7. HISTORY LOGIC ---
  async function loadHistory() {
    const tableBody = document.querySelector("#historyTable tbody");
    tableBody.innerHTML = "<tr><td colspan='3'>Scanning blockchain...</td></tr>";

    if (!window.ethereum) return alert("MetaMask required");
    
    try {
      const provider = new ethers.BrowserProvider(window.ethereum);
      const signer = await provider.getSigner();
      const userAddress = await signer.getAddress();
      const contract = new ethers.Contract(contractAddress, contractABI, provider);

      const currentBlock = await provider.getBlockNumber();
      const CHUNK_SIZE = 40000; 
      const TOTAL_BLOCKS_TO_SCAN = 200000; 
      
      let startBlock = currentBlock - TOTAL_BLOCKS_TO_SCAN;
      if (startBlock < 0) startBlock = 0;

      let allEvents = [];
      console.log(`Scanning from ${startBlock} to ${currentBlock}...`);

      for (let i = startBlock; i < currentBlock; i += CHUNK_SIZE) {
          const from = i;
          const to = Math.min(i + CHUNK_SIZE - 1, currentBlock);
          try {
            const events = await contract.queryFilter("DocumentRegistered", from, to);
            allEvents.push(...events);
          } catch (err) { console.warn("Skipping chunk"); }
      }

      const myEvents = allEvents.filter(e => e.args[2].toLowerCase() === userAddress.toLowerCase());

      tableBody.innerHTML = "";
      if (myEvents.length === 0) {
         tableBody.innerHTML = "<tr><td colspan='3'>No recent documents found.</td></tr>";
         return;
      }

      myEvents.reverse().forEach(e => {
         const hash = e.args[0];
         const cid = e.args[1];
         const shortHash = hash.substring(0, 10) + "..." + hash.substring(60);
         const scanLink = window.location.href.replace('issuer.html', 'scan.html') + `?hash=${hash}`;
         
         const row = `
           <tr>
             <td><a href="${scanLink}" target="_blank">üîó ${shortHash}</a></td>
             <td><a href="https://gateway.pinata.cloud/ipfs/${cid}" target="_blank">üìÑ View File</a></td>
             <td>${e.blockNumber}</td>
           </tr>
         `;
         tableBody.innerHTML += row;
      });

    } catch (e) {
      console.error(e);
      tableBody.innerHTML = `<tr><td colspan='3' style="color:red">Error: ${e.message}</td></tr>`;
    }
  }

  // --- 8. QR CODE GENERATOR (Legacy) ---
  function generateQR() {
    if (!window.currentDocHash) return alert("Upload first!");
    
    const verificationLink = window.location.href.replace('issuer.html', 'scan.html') + `?hash=${window.currentDocHash}`;
    const qrContainer = document.getElementById("qrcode");
    qrContainer.innerHTML = ""; 
    
    new QRCode(qrContainer, { text: verificationLink, width: 128, height: 128 });
  }
</script>
</body>
</html>